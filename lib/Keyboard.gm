//#include "lib/Blink.gm"
#include "lib/String.gm"

global KEYBOARD_EMAIL = "1 2 3 4 5 6 7 8 9 0 <delete> \\ q w e r t z u i o p - \\ a s d f g h j k l @ \\ _ y x c v b n m . , ? \\ <shift> <space> <shift>";
//global KEYBOARD_EMAIL = "1 2 3 4 5 6 7 8 9 0 \\ q w e r t z u i o p \\ a s d f g h j k l \\ <shift> y x c v b n m <delete>";
//global KEYBOARD_NAME = "q w e r t z u i o p <delete> \\ a s d f g h j k l . \\ y x c v b n m , \\ <shift> <space> <shift>";
global KEYBOARD_NAME = "q w e r t z u i o p <delete> \\ a s d f g h j k l . <submit> \\ y x c v b n m , \\ <shift> <space> <shift>";
global KEYBOARD_EN = "!|! 1|1 2|2 3|3 4|4 5|5 6|6 7|7 8|8 9|9 0|0 ?|? <delete> \\ q w e r t y u i o p <enter> \\ a s d f g h j k l . <submit> \\ <shift> z x c v b n m , - <shift> \\ <shift> <alt> <space> <alt> <shift>";global KEYBOARD_PL = "1|1 2|2 3|3 4|4 5|5 6|6 7|7 8|8 9|9 0|0 -|- <delete> \\ q|Q w|W e|E|ę|Ę r|R t|T y|Y u|U i|I o|O|ó|Ó p|P (|( )|) \\ a|A|ą|Ą s|S|ś|Ś d|D f|F g|G h|H j|J k|K l|L|ł|Ł !|! <submit> \\ <shift> z|Z|ż|Ż x|X|ź|Ź c|C|ć|Ć v|V b|B n|N|ń|Ń m|M ,|, .|. ?|? <shift> \\ <alt> <space> <alt>";
global KEYBOARD_MAX = 120;



//-------------------------------------------------------------------------------------------------------------
// LimitText
//-------------------------------------------------------------------------------------------------------------
global function LimitText(textNode) {
    local font = textNode.font;
    local text = textNode.text;
    local newText = "";
    local line = "";
    local spaceIndex = 0;

    for(i=0; i<strlen(text); i+=1) {
        ch = ascii(text[i]);

        if(font.measure(line+ch).x >= textNode.maxWidth) {
            if(spaceIndex) {
                line = line.SetAt(spaceIndex, '\n');
                spaceIndex = 0;
                newText += line;
                line = "";
                //newText += substr(line, 0, spaceIndex);
                //line = substr(line, spaceIndex+1, -1);
            } else {
                newText += line+"\n";
                line = "";
            }
        }

        if(ch == " ") { spaceIndex = strlen(line); }
        line += ch;
    }
    newText += line;
    textNode.text = newText;

    textNode.update().center().middle();
}



/*================================================================================================
* CreateImageButton
*   Creates a button node object from an image, text and fonts.
* ------------------------------------------------------------------------------------------------
*   Package: -
*   Dependencies: -
* ------------------------------------------------------------------------------------------------
*   (string) label    = button text
*   (Font) font       = font for the button text
*   (Image) image     = background image for the button
*   (float) x,y       = position of the button
*   (float) w,h       = width and height of the button; use 0 to use image dimension
*   (func) callback   = callback function for button press
* ------------------------------------------------------------------------------------------------
*   Returns: The button node object.
* ================================================================================================*/
global CreateKeyImageButton = function(label, font, color, image, x, y, w, h, xcenter, ycenter, callback) {
	// check width and height
	if(w <= 0) { w = image.width; }
	if(h <= 0) { h = image.height; }

	// size image to button
	image.width = w;
	image.height = h;

	// create text1 label object for button
	text = Text(label, font);
	text.color = color;
    text.outlineColor = "#ffffff";
    text.outline = 2;
	text.update().middle().center();
	text.x = w * xcenter;
	text.y = h * ycenter;

	// create button node object
	node = NodeEx("button_"+trim(label));
	node.onMouseDown = callback;

	// assign text and image as the childs
	node["image"] = image;
	node["text1"] = text;

	// set position and dimension of node
	node.x = x;  node.y = y;
	node.width = w;  node.height = h;

	return node;
};



/*================================================================================================
* _VirtualKeyboardCallback
*   The global callback for key-presses on the virtual-keyboard.
*   Depends on a global text-box to input the text there!
* ------------------------------------------------------------------------------------------------
*   Package: vkeyboard
*   Dependencies: vkeyboard
* ------------------------------------------------------------------------------------------------
*   (Event) e         = event object
* ================================================================================================*/
global _VirtualKeyboardCallback = function(event) {
	local key = event.sender.key;
	local keyboard = event.sender.proxy.keyboard;
	local input = keyboard.proxy.textbox;

    if(keyboard.onKeyboardInput) { keyboard.onKeyboardInput(event); }

	Blink(event.sender, 1, 0.15, BLINK_MODE_INVERT);

	if(input.text.Length() >= KEYBOARD_MAX && key.Lower() != "<delete>") {
		input.color = "#990000";
		return;
	}
	else {
		input.color = "#ffffff";
	}

	if(key.Lower() == "<delete>") {
		// delete key was pressed
		if(input.text.Length() > 0) {
			newText = "";
			for(i = 0; i < input.text.Length() - 1; i+=1) {
				newText += ascii(input.text[i]);
			}
			input.text = newText;
		}
	} else if(key.Lower() == "<space>") {
		// space key was pressed
		input.text += " ";
	} else if(key.Lower() == "<shift>") {
		keyboard.isShifted = !keyboard.isShifted;
        log("shift "+keyboard.isShifted);
	} else if(key.Lower() == "<alt>") {
        keyboard.isAlt = !keyboard.isAlt;
        log("alt "+keyboard.isAlt);
    } else if(key.Lower() == "<submit>") {
		// the submit button was pressed
        keyboard.onSubmit(input.text);
	} else {
		// normal text input (no special key)
		input.text += event.sender.key;
        LimitText(input);

		// unshift keyboard
        keyboard.isShifted = 0;
        keyboard.isAlt = 0;
	}

    // update keyboard keys by modifiers (shift,alt)
    stateIndex = keyboard.isShifted + keyboard.isAlt * 2;
    i = 0;
    k = keyboard.getChild(i);
    while(k) {
        if(k.states) {
            if(k.states[0][0] != '<') {
                if(k.states.length() > stateIndex) {
                    keyName = k.states[stateIndex];
                    k.key = keyName;
                    k["text1"].text = keyName;
                } else {
                    k.key = "";
                    k["text1"].text = "";
                }
                k["text1"].update().center().middle();
            }
        }
        i += 1; k = keyboard.getChild(i);
    }

    // center input
	input.update().center().middle();
	return true;
};



/*================================================================================================
* _ParseKeysToArray
*   Used by CreateKeyboard() to parse a keyboard definition string to an array of lines for the
*   virtual keyboard creation.
* ------------------------------------------------------------------------------------------------
*   Package: vkeyboard
*   Dependencies: -
* ------------------------------------------------------------------------------------------------
*   (string) keys     = keyboard definition string
* ------------------------------------------------------------------------------------------------
*   Returns: An array of lines for the keyboard generation.
*   Result is like this: lines[line[key]]].
*   A 'key' will have the attributes: key (keycode), width and image
* ================================================================================================*/
global _ParseKeysToArray = function(keys, theme) {
    // try to find images for keys
	if(File().exists("images/key-normal.png")) {  imageNormal = Texture("images/key-normal.png"); } else { imageNormal = theme.Button("", 0, 0, 64, 64, null); }
	if(File().exists("images/key-shift.png"))  {  imageShift = Texture("images/key-shift.png"); } else { imageShift  = theme.Button("", 0, 0, 64, 64, null); }
    if(File().exists("images/key-space.png"))  {  imageSpace = Texture("images/key-space.png"); } else { imageSpace  = theme.Button("", 0, 0, 64*10, 64, null); }
	if(File().exists("images/key-submit.png")) {  imageSubmit = Texture("images/key-submit.png"); } else { imageSubmit = theme.Button("", 0, 0, 128, 64, "#9ae337"); }
	if(File().exists("images/key-delete.png")) {  imageDelete = Texture("images/key-delete.png"); } else { imageDelete = theme.Button("", 0, 0, 64, 64, "#e35555"); }
	if(File().exists("images/key-alt.png"))    {  imageAlt = Texture("images/key-alt.png"); } else { imageAlt = theme.Button("", 0, 0, 64, 64, null); }

    if(File().exists("images/key-normal-overlay.png")) { imageNormal["overlay"] = Texture("images/key-normal-overlay.png", imageNormal.width/2, imageNormal.height/2).update().center().middle(); }
    if(File().exists("images/key-shift-overlay.png")) { imageShift["overlay"] = Texture("images/key-shift-overlay.png", imageShift.width/2, imageShift.height/2).update().center().middle(); }
    if(File().exists("images/key-space-overlay.png")) { imageSpace["overlay"] = Texture("images/key-space-overlay.png", imageSpace.width/2, imageSpace.height/2).update().center().middle(); }
    if(File().exists("images/key-submit-overlay.png")) { imageSubmit["overlay"] = Texture("images/key-submit-overlay.png", imageSubmit.width/2, imageSubmit.height/2).update().center().middle(); }
    if(File().exists("images/key-delete-overlay.png")) { imageDelete["overlay"] = Texture("images/key-delete-overlay.png", imageDelete.width/2, imageDelete.height/2).update().center().middle(); }
    if(File().exists("images/key-alt-overlay.png")) { imageAlt["overlay"] = Texture("images/key-alt-overlay.png", imageAlt.width/2, imageAlt.height/2).update().center().middle(); }

	// the lines array is the result of this function
	local lines = Array();
	lines.maxWidth = 0;
	lines.count = 1;

	// the line array will contain an array of keys
	local line = Array();
	line.lineWidth = 0;
	lines.add(line);

	local tmp = "";
	local keys = keys + " ";
	local parseWidth = false;
    local parseAlt = false;

    // iterate through sequence of characters
	for(i=0; i<keys.Length(); i+=1) {
		k = ascii(keys[i]);

		if(k == "\\") { // next column line on keyboard
			line = Array();
			line.lineWidth = 0;
			lines.add(line);
			lines.count += 1;
			i += 1; // skip next space
			continue;
		}

        if(k == " " || k == "\t") {  // space for next key
            // find extra options
            local optionsIndex = findstr(tmp, ":");
            if(optionsIndex != -1) {
                tmp = split(tmp, ":", false);
                options = tmp[1];
                tmp = tmp[0];
                optionWidth = options.Int();
            }

            // create key
            // read key states (normal|shifted|alt|alt+shifted)
            local key = Object();
            key.states = split(tmp, "|", false);
            key.key = key.states[0];
            key.width = optionWidth;
            tmp = "";

			// set key image
            if(key.states[0] == "<delete>") { key.image = imageDelete; }
			if(key.states[0] == "<shift>")  { key.image = imageShift; }
			if(key.states[0] == "<space>")  { key.image = imageSpace; }
			if(key.states[0] == "<submit>") { key.image = imageSubmit; }
            if(key.states[0] == "<alt>")    { key.image = imageAlt; }
			if(key.image == null)           { key.image = imageNormal; }

            // update line
			line.lineWidth += key.image.width;
			if(lines.maxWidth < line.lineWidth) { lines.maxWidth = line.lineWidth; }
			line.add(key);

            optionWidth = 0;
			continue;
		}

		tmp += k;
	}

	return lines;
};



/*================================================================================================
* CreateKeyboard
*   Used by CreateKeyboard() to parse a keyboard definition string to an array of lines for the
*   virtual keyboard creation.
* ------------------------------------------------------------------------------------------------
*   Package: vkeyboard
*   Dependencies: -
* ------------------------------------------------------------------------------------------------
*   (string) keys     = keyboard definition string
* ------------------------------------------------------------------------------------------------
*   Returns: An array of lines for the keyboard generation.
* ================================================================================================*/
global CreateKeyboard = function(inKeys, theme, screenWidth, screenHeight) {
	local font = theme.getFont("button");

    // create keyboard object
    local root = Node();
	root.isShifted = false;
    root.isAlt = false;

	// parse the keyboard-defintion string to a lines-array
	local lines = _ParseKeysToArray(inKeys, theme);

	// keyboard screen position offset
	local off_x = (screenWidth / 2)/* - (lines.totalWidth * image.width) / 2*/;
	local off_y = (screenHeight / 2) - (lines.count * 72) / 2;

	// create buttons for each keyboard key
	local cur_x = 0;
	local cur_y = off_y;
	local counter = 0;
	foreach(l in lines) {
		cur_x = off_x + -l.lineWidth / 2;

		local h = 0;
		foreach(k in l) {
			if(k.image == null) { continue; }  // key has no image/appearance!

			// create the key buttons (visible nodes for the scene graph)
			if(k.states[0][0] == '<') { keyNode = CreateKeyImageButton("  ", font, "#000000", k.image, cur_x, cur_y, 0, 0, 0.5, 0.5, _VirtualKeyboardCallback);
			} else {                    keyNode = CreateKeyImageButton(k.states[0], font, "#000000", k.image, cur_x, cur_y, k.width, 0, 0.50, 0.65, _VirtualKeyboardCallback); }

			// store keyboard root node in key (needs a proxy object because otherwise it will render the keyboard, causing an infinite render loop)
			keyNode.proxy = Object("_proxy");
			keyNode.proxy.keyboard = root;

			// fix image height
            if(h < k.image.height) { h = k.image.height; }

			// advance x-position
            cur_x += k.image.width;  //  + 10

            // store additional information in node
			keyNode.key = k.key;
            keyNode.states = k.states;

            // attach node to keyboard root
			root["_"+counter] = keyNode;

			// advance counter
            counter += 1;
		}

		cur_y += h;  //  + 10
	}

	// register function to change keyboard textbox
	root.SetTextbox = function(tb) {
		log("Textbox of keyboard set to " + tb.toString());
		this.proxy = Object("_proxy");
		this.proxy.textbox = tb;
	};

	// return keyboard node
	return root;
};
